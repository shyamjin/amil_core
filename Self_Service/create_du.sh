#!/usr/bin/env bash

# Create a 'DU' for Value Pack.

# The goal is to create artifacts from the Amily 'self service' functionality (and related end-user tasks) that can be
# deployed via the Value Pack DPM and its front-end GUI. These artifacts are generated from with the runtime
# environments and do not get back-propagated into source control. Instead, they are archived in a (Nexus) repository
# near to the runtime environment, to give the end-user an some ability of versioned deployments of the artifacts.
#
# These artifacts include:
# - Models (.pkl files generated by Amily Self Service)
# - Threshold configuration (.json files)

# SCRIPT INPUTS:
# - Artifact Name (e.g. "Account_Name_ext_model")
# - Unique Sequence Number (can also use a UTS ticket ID which triggered the self-service request, such as 000000000001610)
# - Release notes (a description string which will appear against the DU in the DPM GUI)
# - List of files to include in the zip (space delimited)
#
# ENVIRONMENT (default values are provided in this script)
# - AMILY_VP_NEXUS_URL = Base URL for NEXUS - http://nexus_host:port/nexus  (do not include anything after /nexus)
# - AMILY_VP_NEXUS_USER = username for creating an artifact
# - AMILY_VP_NEXUS_PASS = password
# - AMILY_VP_NEXUS_REPO = name of the Nexus repository
# - AMILY_VP_NEXUS_GROUP = Group name to use for the artifact
# - AMILY_DPM_BASE_URL = Base URL of the DPM to use for the REST API
# - AMILY_DPM_AUTH_TOKEN = Authorization token to access the DPM REST API
# - AMILY_WS_HOME = directory path to the Amily web service home (e.g. /prjvl01/amily/Amily_Prod)
#
# RETURN CODES
# 0 = all ok
# 1 = error
#
# SIDE EFFECTS
# .zip file will be created and uploaded to Nexus, containing the user-supplied files plus an 'install.sh' script
# which will place the files into the appropriate target directories in the Amily web service file space.


# --- Get user inputs
command="$0"
artifact_name="$1"
artifact_version="$2"
description="$3"
shift
shift
shift
file_list="$@"

# --- Global script variables
TEMP_DIR=/dev/shm/create_du.tmp
DPM_NEXUS_URL=http://vp_nexus:8081/nexus     # This is the DPM internal base URL, which uses the DPM's internal hostname for Nexus.
zipfile="${artifact_name}-${artifact_version}.zip"
zip_url_in_nexus=       # will be populated later


# === SCRIPT FUNCTIONS ===
function print_usage_and_exit
{
    echo $@
    echo "Usage: $0 {artifact_name} {artifact_version} {description} {file ...}"
    exit 1
}

function clean_exit
{
    exit_code=$1
    if [[ -d ${TEMP_DIR} ]]
    then
        cd
        rm -rf ${TEMP_DIR:-/dev/null}
    fi
    exit $1
}

function print_error_and_exit
{
    echo -e "$@"
    clean_exit 1
}

function validate_environment
{
    for varname in \
        AMILY_VP_NEXUS_URL   \
        AMILY_VP_NEXUS_USER  \
        AMILY_VP_NEXUS_PASS  \
        AMILY_VP_NEXUS_REPO  \
        AMILY_VP_NEXUS_GROUP \
        AMILY_DPM_BASE_URL   \
        AMILY_DPM_AUTH_TOKEN \
        AMILY_WS_HOME
    do
        x=$(eval echo \$${varname})
        case $varname in
            *_PASS )    y='****' ;;
            *_TOKEN )   y='********' ;;
            * )         y=$x ;;
        esac
        echo "$varname = $y"
        if [[ -z ${x} ]]
        then
            print_error_and_exit "FATAL: Environment variable [${varname}] is not set"
        fi
    done

}

function validate_user_inputs
{
    # --- Validate inputs
    if [[ -z ${artifact_name} ]]
    then
        print_usage_and_exit "Must provide artifact name"
    fi

    if [[ -z ${artifact_version} ]]
    then
        print_usage_and_exit "Must provide artifact version sequence ID"
    fi

    if [[ ! ${artifact_version} =~ ^[0-9][0-9]*$ ]]
    then
        print_usage_and_exit "Artifact version must be a number"
    fi

    if [[ -z ${artifact_version} ]]
    then
        print_usage_and_exit "Must provide a description text"
    fi

    if [[ -z "${file_list}" ]]
    then
        print_usage_and_exit "Must supply a list of files to include in the DU"
    fi
}

function create_temp_dir
{
    mkdir -p ${TEMP_DIR}                || print_error_and_exit "Something bad happened when trying to create a temp directory"
    rm -f ${TEMP_DIR:-/dev/null}/*      || print_error_and_exit "Something bad happened when trying to create a temp directory"
}

function copy_files_to_temp_dir
{
    cp -v ${file_list} ${TEMP_DIR}         || print_error_and_exit "Error while copying artifacts to temp directory"
    cp -v ${command%/*}/handle_du.sh ${TEMP_DIR}   || print_error_and_exit "Failed to locate the script 'handle_du.sh' required for bundling into the DU"
}

function create_du_handling_scripts
{
    echo '. handle_du.sh install'   > ${TEMP_DIR}/install.sh
    echo '. handle_du.sh redeploy'  > ${TEMP_DIR}/redeploy.sh
    echo '. handle_du.sh uninstall' > ${TEMP_DIR}/uninstall.sh
}

function create_du_zip
{
    # Create a zip file, which is the DU
    echo "Creating ZIP file ${zipfile} ..."

    cd ${TEMP_DIR}
    zip ${zipfile} * || print_error_and_exit "Error creating zip file"
    cd -  >/dev/null

    echo
}

function push_to_nexus
{
    # --- use curl to upload the zip file to Nexus
    vp_nexus_group_with_slashes=${AMILY_VP_NEXUS_GROUP//./\/}
    zip_url_in_nexus=${AMILY_VP_NEXUS_URL}/content/repositories/${AMILY_VP_NEXUS_REPO}/${vp_nexus_group_with_slashes}/${artifact_name}/${artifact_version}/${zipfile}
    zip_url_in_dpm=${AMILY_VP_NEXUS_URL}/content/repositories/${AMILY_VP_NEXUS_REPO}/${vp_nexus_group_with_slashes}/${artifact_name}/${artifact_version}
    echo "Uploading to Nexus URL: ${zip_url_in_nexus} ..."
    curl_output="$(curl -v -u ${AMILY_VP_NEXUS_USER}:${AMILY_VP_NEXUS_PASS} --upload-file ${TEMP_DIR}/${zipfile} ${zip_url_in_nexus} 2>&1)"

    if [[ $? -ne 0 ]]; then print_error_and_exit "ERROR uploading zip file DU to Nexus"; fi
    if ( echo "${curl_output}" | egrep -q '^< HTTP/[^ ]* (200|201)' )
    then
        echo ".. uploaded successfully to [${zip_url_in_nexus}]"
    else
        print_error_and_exit ".. ERROR uploading to zip file DU to Nexus:\n----------------------------------------\n${curl_output}\n----------------------------------------\n"
    fi

    echo
}

function inform_dpm
{
    # === Tell DPM that a new zip file has been uploaded.

    # --- First query the DPM to see if the DU exists
    query_du_url="${AMILY_DPM_BASE_URL}/deploymentunit/search/name/${artifact_name}"
    echo "Querying the DPM to see if the DU is already defined"
    echo ".. URL: ${query_du_url}"
    query_response=$(curl -v -k -H Access-Token:\ ${AMILY_DPM_AUTH_TOKEN} -H details:\ false "${query_du_url}" 2>&1)
    if [[ ! ${query_response} =~ \"result\":\ \"success\" ]]
    then
        print_error_and_exit "Error communicating with DPM on query:\n----------------------------------------\n${query_response}\n----------------------------------------\n"
    fi

    # --- If the DU does not exist, create it
    if [[ ${query_response} =~ \"data\":\ null ]]
    then
        echo ".. DPM says DU does not exist yet"

        new_du_details='{"name":"'${artifact_name}'", "type":"Version", "release_notes":"'${description}'", "deployer_to_use":"DefaultDeploymentPlugin","repository_to_use" : "DefaultNexus2Repository"}'
        new_du_url="${AMILY_DPM_BASE_URL}/deploymentunit/new"
        echo "Sending request to create new DU"
        echo ".. URL: ${new_du_url}"
        echo ".. Payload: ${new_du_details}"
        create_response=$(curl -v -k "${new_du_url}" -H 'Content-Type: application/json' -H Access-Token:\ ${AMILY_DPM_AUTH_TOKEN} -d "${new_du_details}" 2>&1)
        if [[ ! ${create_response} =~ \"result\":\ \"success\" ]]
        then
            print_error_and_exit "Error communicating with DPM on create DU:\n----------------------------------------\n${create_response}\n----------------------------------------\n"
        fi
        # --- grab the DU ID
        du_id=$(echo $create_response|sed 's/^.*"_id": "\([^"]*\)".*$/\1/')
    else
        # --- grab the DU ID
        du_id=$(echo $query_response|sed 's/^.*"\$oid": "\([^"]*\)".*$/\1/')
        echo ".. DPM says DU does exists, we got ID [${du_id}]"
    fi

    # --- check the ID actually looks like an ID
    if [[ ! ${du_id} =~ ^[0-9a-f][0-9a-f]*$ ]]
    then
        print_error_and_exit "Failed to extract the DU ID from the response from DPM Create DU API response\nConversation:\n${create_response}"
    fi

    # --- Add a 'build' to the DU
    zipfile_size=$( cd ${TEMP_DIR}; du -h ${zipfile} | awk '{print $1}' )
    zip_url_in_dpm_nexus=${zip_url_in_nexus/${AMILY_VP_NEXUS_URL}/${DPM_NEXUS_URL}}   # replace external URL host with internal DPM hostname for Nexus
    zip_url_in_dpm_nexus_build_add=${zip_url_in_dpm/${AMILY_VP_NEXUS_URL}/${DPM_NEXUS_URL}}
    new_du_build_json='
{
    "status": "1",
    "build_number": "'${artifact_version}'",
    "package_name": "'${zipfile}'",
    "package_type": "zip",
    "parent_entity_id": "'${du_id}'",
    "type": "url",
    "file_path": "'${zip_url_in_dpm_nexus}'",
    "file_size": "'${zipfile_size}'",
    "repo_type": "nexus",
    "additional_info": {
        "version": "'${artifact_version}'",
        "package": "'${AMILY_VP_NEXUS_GROUP}'",
        "artifact": "'${artifact_name}'",
        "repo_id": "'${AMILY_VP_NEXUS_REPO}'",
        "relative_path": "'${zip_url_in_dpm_nexus_build_add#*/repositories/}'",
        "file_name": "'${zipfile}'"
    }
}
'
    new_du_build_url="${AMILY_DPM_BASE_URL}/build/add"
    echo "Sending request to add new DU build"
    echo ".. URL: ${new_du_build_url}"
    echo ".. Payload: ${new_du_build_json}"
    addbuild_response=$(curl -v -k "${new_du_build_url}" -H 'Content-Type: application/json' -H Access-Token:\ ${AMILY_DPM_AUTH_TOKEN} -d "${new_du_build_json}" 2>&1)
    if [[ ! ${addbuild_response} =~ \"result\":\ \"success\" ]]
    then
        print_error_and_exit "Error communicating with DPM on add DU build:\n----------------------------------------\n${addbuild_response}\n----------------------------------------\n"
    fi

    echo "Add DU build completed successfully"
}

# === MAIN ===

validate_user_inputs
validate_environment
create_temp_dir
copy_files_to_temp_dir
create_du_handling_scripts
create_du_zip
push_to_nexus
inform_dpm

echo "Finished."
clean_exit 0
